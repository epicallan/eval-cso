module Agent.Controller
       ( createAgentProfile
       , updateAgent
       , getAgentByUserName
       ) where

import Control.Monad.Time (MonadTime)
import Database.Persist.Postgresql (toSqlKey)
import Servant (err400)

import Agent.Model.Types (AgentModel(..))
import Agent.Types (AgentAttrs, AgentResponse(..), HasCreateAgent(..))
import Common.Errors (MonadThrowLogger, eitherSError)
import Common.Types (Id(..))
import Foundation (HasSettings)
import Db.Model (Agent(..), Branch(..), User)
import User.Controller (generateUser)
import User.Helper (runProtectedAction, toUserResponse)
import User.Model.Types (UserModel(..))
import qualified User.Types as U (UserName(..))
import User.Types (Role(CsoAgent))

-- | called when an agent is being auto generated by admin or evaluator
createAgentProfile
  :: (HasSettings r, MonadReader r m, MonadTime m, MonadThrowLogger m
     , HasCreateAgent attrs, MonadIO m
     )
  => AgentModel m
  -> UserModel m
  -> User -- ^ logged in user
  -> attrs -- ^ A combination of user and agent specific attributes
  -> m Id
createAgentProfile agentModel usModel logedInUser attrs = do
  uid <- generateUser usModel logedInUser $ attrs ^. caUserAttrs
  eitherSError err400 =<<
    amCreateAgent agentModel (toSqlKey $ unId uid) (attrs ^. caAgentAttrs)

-- | used in creating agent profile when agent exists after signup as a user
updateAgent
  :: MonadThrowLogger m
  => AgentModel m
  -> User -- ^ The current logged in user
  -> Text -- ^ Agent User name
  -> AgentAttrs
  -> m ()
updateAgent agentModel logedInUser name attrs = do
  let userName = U.UserName name

  eitherSError err400 =<< runProtectedAction
    logedInUser
    CsoAgent
    (amUpdateAgent agentModel userName attrs)

getAgentByUserName
  :: MonadThrowLogger m
  => AgentModel m
  -> Text -- ^ Agent user name
  -> m AgentResponse
getAgentByUserName agentModel name = do
  let userName = U.UserName name
  agentUser <- eitherSError err400 =<< amGetAgentByName agentModel userName
  uncurry (toAgentResponse agentModel) agentUser

toAgentResponse
  :: MonadThrowLogger m
  => AgentModel m
  -> Agent
  -> User -- ^ Agent User attributes
  -> m AgentResponse
toAgentResponse agentModel agent user = do
  mSupervisor <- traverse (amGetUserById agentModel) $ agentSupervisorId agent
  mBranch <- traverse (amAgentBranch agentModel) $ agentBranch agent
  arServices <- traverse (amAgentServices agentModel) $ agentServices agent
  let arSupervisor = toUserResponse <$> join mSupervisor
      arBranch = branchName <$> join mBranch
      arUser = toUserResponse user
  pure AgentResponse {..}
