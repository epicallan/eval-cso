module Agent.Controller
       ( createAgentProfile
       , updateAgent
       , getAgentById
       ) where

import Control.Monad.Time (MonadTime)
import Database.Persist.Postgresql (toSqlKey)
import Servant (err400)

import Agent.Model.Types (AgentModel(..))
import Agent.Types
  (AgentAttrs, AgentErrors(..), AgentResponse(..), HasCreateAgent(..))
import Common.Errors (throwSError)
import Common.Types (Id(..))
import Foundation (HasConfig)
import Model (Agent(..), Branch(..), User)
import User.Controller (generateUser)
import User.Helper (runProtectedAction, toUserResponse)
import User.Model.Types (UserModel(..))
import User.Types (Role(CsoAgent))

-- | called when an agent is being auto generated by admin or evaluator
createAgentProfile
  :: (HasConfig r, MonadReader r m, MonadTime m, MonadThrow m
     , HasCreateAgent attrs
     )
  => AgentModel m
  -> UserModel m
  -> User -- ^ logged in user
  -> attrs -- ^ A combination of user and agent specific attributes
  -> m Id
createAgentProfile agentModel usModel logedInUser attrs = do
  uid <- generateUser usModel logedInUser $ attrs ^. caUserAttrs
  amCreateAgent agentModel (toSqlKey $ unId uid) (attrs ^. caAgentAttrs)

-- | used in creating agent profile when agent exists after signup as a user
updateAgent
  :: MonadThrow m
  => AgentModel m
  -> UserModel m
  -> User -- ^ The current logged in user
  -> Int64 -- ^ Agent User Id
  -> AgentAttrs
  -> m AgentResponse
updateAgent agentModel usModel logedInUser uid attrs = do
  let userId = toSqlKey uid

  runProtectedAction
    logedInUser
    CsoAgent $
    amUpdateAgent agentModel userId attrs

  getAgentById agentModel usModel uid

getAgentById
  :: MonadThrow m
  => AgentModel m
  -> UserModel m
  -> Int64 -- ^ Agent user Id
  -> m AgentResponse
getAgentById agentModel usModel uid = do
  mAgentUser <- amGetAgentById agentModel (toSqlKey uid)
  let toAgentResponse' = uncurry $ toAgentResponse agentModel usModel
      throwUpdateError = throwSError err400 $ AgentUpdateError $ Id uid
  maybe throwUpdateError toAgentResponse' mAgentUser

toAgentResponse
  :: MonadThrow m
  => AgentModel m
  -> UserModel m
  -> Agent
  -> User -- ^ Agent User attributes
  -> m AgentResponse
toAgentResponse agentModel usModel agent user = do
  mSupervisor <- traverse (umGetUsersById usModel) $ agentSupervisorId agent
  mBranch <- traverse (amAgentBranch agentModel) $ agentBranch agent
  arServices <- traverse (amAgentServices agentModel) $ agentServices agent
  let arSupervisor = toUserResponse <$> join mSupervisor
      arBranch = branchName <$> join mBranch
      arUser = toUserResponse user
  pure AgentResponse {..}
